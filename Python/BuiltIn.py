'''Python 2.7's built-in functions and types.Function documentation from built-in docstringsprinted in IPython. Note that optional argumentsare displayed in brackets in these docstrings,e.g., function(formal_arg1[, optional_arg]) meansthat optional_arg is optional, as are the commaand whitespace preceeding it.OFFICIAL PYTHON DOCUMENTATION -- ALL BUILT-IN FUNCTIONS:http://docs.python.org/library/functions.html#built-in-functionsNumeric Types Documentation:  http://docs.python.org/library/stdtypes.html#numeric-types-int-float-long-complex'''#===============================================================================#                            TYPES#===============================================================================#                         ----------#              ~~~~~~~~~  DATA TYPES  ~~~~~~~~~#                         ----------# bool'''Returns True when the argument x is true, False otherwise.   The builtins True and False are the only two instances of the class bool.   The class bool is a subclass of the class int, and cannot be subclassed.      bool(x) --> bool      http://docs.python.org/library/functions.html#bool   '''True            # True object -- do not override!False           # False object -- do not override!True is True    # is TrueFalse is False  # is TrueTrue is False   # is False1 > 0           # is True1 == 0          # is False#-------------------------------------------------------------------------------# complex'''Create a complex number from a real part and   an optional imaginary part. This is equivalent   to (real + imag*1j) where imag defaults to 0.   complex(real[, imag]) --> complex number      http://docs.python.org/library/functions.html#complex   '''complex(1)      # returns (1+0j)complex(1, 1)   # returns (1+1j)complex(0, 0)   # returns 0jcomplex(0, 1)   # returns 1j    # useful methodsfoo = complex(1, 2) # (1+2j)foo.conjugate()     # (1-2j), complex conjugatefoo.real            # 1.0, foo's real componentfoo.imag            # 2.0, foo's imaginary component#-------------------------------------------------------------------------------# float'''Convert a string or number to a floating point    number, if possible.      float(x) --> floating point number      http://docs.python.org/library/functions.html#float   '''float(5)                # returns 5.0float(5.0)              # returns 5.0float('5')              # returns 5.0float(complex(1))       # returns TypeError: can't convert complex to float    # useful methodsfoo = 0.75foo.as_integer_ratio()  # returns (3, 4)foo.conjugate()         # returns foo, its own complex conjugatefoo.hex()               # returns '0x1.8000000000000p-1', a hexadecimal                         # representation of foofoo.imag                # returns 0, foo's imaginary componentfoo.real                # returns foo, foo's real componentfoo.is_integer()        # returns False, because foo is not equal to any integer#-------------------------------------------------------------------------------# int'''Convert a string or number to an integer, if possible.  A floating point   argument will be truncated towards zero (this does not include a string   representation of a floating point number!)  When converting a string, use   the optional base.  It is an error to supply a base when converting a   non-string.  If base is zero, the proper base is guessed based on the   string content.  If the argument is outside the integer range a   long object will be returned instead.      int(x[, base]) --> integer      http://docs.python.org/library/functions.html#int   '''int(5.0)    # returns 5int(5.999)  # returns 5int('5')    # returns 5int('5.')   # returns ValueError: invalid literal for int() with base 10: '5.'int(complex(0)) # returns TypeError: can't convert complex to int    # useful methodsfoo = 5foo.bit_length()        # returns 3, the number of bits needed                         # to represent foo in binary#-------------------------------------------------------------------------------# long'''Convert a string or number to a long integer, if possible.  A floating   point argument will be truncated towards zero (this does not include a   string representation of a floating point number!)  When converting a   string, use the optional base.  It is an error to supply a base when   converting a non-string.      long(x[, base]) --> integer      http://docs.python.org/library/functions.html#long      AUTHOR: Long integers have theoretically ulimited precision. They have the           same methods as normal integers. See 'int' for methods.   '''#-------------------------------------------------------------------------------# str'''Return a nice string representation of the object.   If the argument is a string, the return value is the same object.      str(object) --> string      http://docs.python.org/library/functions.html#str   '''str(5)        # returns '5'str(5.)       # returns '5.0'str(5.0)      # returns '5.0'str('string') # returns 'string'str([])       # returns '[]'str((1,2,3))  # returns '(1,2,3)'str(str)      # returns "<type 'str'>"# the following returns True # (compares literal string to Unicode string, #  see unicode type below)'' == u''    # useful methodsfoo = 'string'foo.capitalize()         # returns 'String'foo.center(9)            # returns '  string ', a string of length 10 with foo                          # centered as much as possiblefoo.count('str')         # returns 1, the no. of times that 'str' occurs in foofoo.decode()             # returns u'string'. You can specify an encoding to use                         # and error handling behavior.foo.encode()             # returns 'string'. " " " " "foo.endswith('ing')      # returns True, bc foo ends in 'ing'. 'ing' could also                          # be a tuple of strings to try.foo.expandtabs(90000)    # returns 'string'. This replaces tabs with 90000                          # characters; by default, leave blank for 8.foo.find('ing')          # returns 3, the lowest index where '                         # ing' is found in foofoo.isalpha()            # returns True, bc all chars in foo are alphabeticalfoo.isdigit()            # returns False, bc not all chars in foo are numericfoo.isalnum()            # returns False, bc foo does not contain at least 1                          # alphabetical char and at least 1 number (foo is not                          # alphanumeric)foo.islower()            # returns True, bc all chars in foo are lower casefoo.isupper()            # returns false, bc not all chars in foo are upper casefoo.istitle()            # returns false, bc foo's first char is not capitalized                         # ('String'.istitle() is True)foo.isspace()            # returns false, bc foo does not contain all whitespacefoo.join('123')          # returns '1string2string3' by using foo to join each                          # element in the iterable (can be any iterable!)foo.ljust(10)            # returns 'string    ', a string of length 10 with foo                          # left-justified in itfoo.lower()              # returns 'string', foo in lower casefoo.lstrip('str')        # returns 'ing' by removing whitespace or the input                          # string (which is 'str' here) from the left side of                          # the string, nowhere elsefoo.partition('ri')      # returns ('st','ri','ng') by getting what's left of                          # 'ri', 'ri' and what's right of 'ri'foo.replace('s', '5', 1) # returns '5tring' by replacing 's' with '5', a                          # maximum of 1 timefoo.rfind('ing')         # returns 3 by finding the highest index (as opposed to                         # lfind's lowest index) where 'ing' occurs in foofoo.rjust(10)            # returns '    string', a string of length 10 with foo                          # right-justified in itfoo.rpartition('ri')     # returns ('st', 'ri', 'ng') by starting from the right                         # finding 'ri' and getting it and the adjacent strings.foo.rsplit('ri', 1)      # returns ['st','ng'] by starting from the right,                          # finding 'ri' and splitting foo 1 timefoo.rstrip('ing')        # returns 'str' by starting from the right, finding                          # 'ing' and removing itfoo.split('ri', 1)       # returns ['st', 'ng'] by starting from the left,                          # finding 'ri' and splitting foo 1 time'\n1\n'.splitlines(True) # returns ['\n', '1\n'] by splitting at newlines. True                          # says 'keep newline chars', and is optional. By                          # default, newline chars are removed.foo.startswith('str')    # returns Truefoo.strip('st')          # returns 'ring'foo.swapcase()           # returns 'STRING' by swapping the case for each                          # character in foofoo.title()              # returns 'String' by capitalizing the first char and                          # lower-casing all other chars in foofoo.upper()              # returns 'STRING' by making all characters upper case                         # in foofoo.zfill(10)            # returns '0000string' by padding foo on the left                          # until a string of length 10 is made#-------------------------------------------------------------------------------# slice'''Create a slice object.     This is used for extended slicing (e.g. a[0:10:2]).      slice([start,] stop[, step]) --> slice object      http://docs.python.org/library/functions.html#slice   '''slice(5)        # returns slice(None, 5, None)slice(0, 5)     # returns slice(0, 5, None)slice(0, 5, 2)  # return slice(0, 5, 2)[0,1,2,3,4,5][slice(0,5,2)] # returns [0,2,4][0,1,2,3,4,5][0:5:2]        # returns [0,2,4]    # useful methodsfoo = slice(0, 10, 2)foo.indices(10)         # returns (0, 10, 2) by finding                         # (startIndex, endIndex, stride) in a sequence of length                        # 10foo.start               # returns 0foo.stop                # returns 10foo.step                # returns 2#-------------------------------------------------------------------------------# type'''type(object) --> the object's type   type(name, bases, dict) --> a new type      http://docs.python.org/library/functions.html#type   '''type('5')   # returns <type 'str'>type(5.0)   # returns <type 'float'>type(type)  # returns <type 'type'>if type(5.) == type(5.0): # True    '5. and 5.0 have the same type'#-------------------------------------------------------------------------------# unicode'''Create a new Unicode object from the given encoded string.   encoding defaults to the current default string encoding.   errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.   unicode(string [, encoding[, errors]]) --> object   AUTHOR: I highly recommend http://docs.python.org/howto/unicode.html   http://docs.python.org/library/functions.html#unicode   '''unicode('string')   # returns u'string'unicode(u'string')  # returns u'string'unicode(5)          # returns u'5'unicode(5.)         # returns u'5.0'    # useful methods -- shares many with str, with some notable additionsfoo = u'12345'foo.isdecimal()     # returns Truefoo.isnumeric()     # returns True#                          --------------------------------#               ~~~~~~~~~  DATA CONTAINTERS/DATA STRUCTURES  ~~~~~~~~~#                          --------------------------------# list'''list() --> new empty list   list(iterable) --> new list initialized from iterable's items      http://docs.python.org/library/functions.html#list   '''list()                            # returns []list((1,2,3))                     # returns [1, 2, 3]list('123')                       # returns ['1', '2', '3'][ [], [] ]                        # returns [[],[]], a list of lists[1, '1', 1., type, [], (,), u'']  # lists do not constrain type[1] + [2]                         # returns [1,2], NOT [3][1] * 5                           # returns [1,1,1,1,1]                                  # !NB: '+' and '*' are the only supported                                  # operands for lists; don't go trying to                                  # subtract, divide or modulate.                                  # This behavior also applies to tuples.    # slicing (applies to nearly all iterables!)[1, 2, 3][0]                      # returns 1, the element in the list at                                  # index 0[1, 2, 3][:2]                     # returns [1,2] by slicing the list in the                                  # half-open interval [0,2)[1, 2, 3][:-1]                    # returns [1,2] by retrieving everything                                  # left of the '-1' (last) element in the list[1, 2, 3][-3]                     # returns 1, the '-3' element in the list[1, 2, 3][:9000]                  # returns [1,2,3] -- no error raised in Py27[1, 2, 3][9000:]                  # returns [][1, 2, 3][9000]                   # returns indexError: list index out of range[1, 2, 3][::2]                    # returns [1,3] by stepping by 2    # useful methodsfoo = [] + []          # an empty list - rectangular brackets.foo.append(0)          # appends 5 to foo, foo becomes [0]foo.extend([1,2,3])    # appends 1, 2 and 3 to foo, foo becomes [0,1,2,3]foo.append([1,2,3])    # appends [1,2,3] to foo, foo becomes                        # [0, 1, 2, 3, [1,2,3]]foo.count(1)           # returns 1, the number of times 1 is in foofoo.index([1,2,3])     # returns 4, the first index with value [1,2,3]foo.insert(1, 999)     # inserts 999 before index 1, foo becomes                        # [0, 999, 1, 2, 3, [1,2,3]]foo.pop()              # remove and return last item from foo, [1,2,3]. foo                        # becomes [0, 999, 1, 2, 3]foo.remove(999)        # remove first occurrence of 999, foo becomes                        # [0, 1, 2, 3]foo.reverse()          # reverse foo in-place, foo becomes [3, 2, 1, 0]foo.sort()             # sort foo in-place, foo becomes [0, 1, 2, 3]foo.sort(reverse=True) # sort foo in-place in reverse order, foo becomes                        # [3, 2, 1, 0]#-------------------------------------------------------------------------------# dict'''dict() --> new empty dictionary      dict(mapping) --> new dictionary initialized from a mapping object's   (key, value) pairs      dict(iterable) --> new dictionary initialized as if via:   d = {}   for k, v in iterable:       d[k] = v          dict(**kwargs) --> new dictionary initialized with the name=value pairs   in the keyword argument list.  For example:  dict(one=1, two=2)      Author: Dictionaries are extremely powerful tools because they can           use any hashable object as a key to any value. This makes them            great for crosswalks, lookup tables and simple caching. Note           that because dictionary keys are unique and unordered, they           have set-like properties, meaning they are good for fast           lookups (i.e. '1' in {1:2} is fast) but they are bad for           order-based logic. For that, use `collections.OrderedDict`.              http://docs.python.org/library/stdtypes.html#dict   '''dict()              # returns {}, an empty dictionarydict((1,2), (3,4))  # returns {1:2, 3:4}{1:2, 3:4}[3]       # returns 4, the 'value' linked to the 'key' 3                    # note that dictionary keys are unique, but values                    # can be any object!{1:2, 3:4}[5] = 6   # gives this dict a key 5 that links to a value 6,                     # becomes {1:2, 3:4, 5:6}    # useful methodsfoo = {}                   # an empty dictionaryfoo.clear()                # clear foo...no changes herefoo.copy()                 # returns a 'shallow' copy of foofoo.update([(1,2), (3,4)]) # foo gains {1:2, 3:4}, becoming {1:2, 3:4}foo.update([(5,6)])        # foo gains {5:6}, becoming {1:2, 3:4, 5:6}foo.get('I')               # returns None, bc 'I' is not a key in foofoo.get('I', 5)            # returns 5, bc 'I' is not a key in foofoo.get(3, 5)              # returns foo[3], which is 4. Nothing happens with 5foo.get(3)                 # returns foo[3], which is 4foo.setdefault('I', 40)    # returns foo.get('I',40) and sets foo['I'] to 40 if                           # 'I' is not a key of foo (which it is not) so foo                           # becomes {1:2, 3:4, 5:6, 'I':40}foo.has_key('I')           # returns true bc foo contains 'I' as a keyfoo.keys()                 # returns the keys of foo in a sorted list; returns                           # ['I', 1, 3, 5]foo.values()               # returns the values of foo, sorted by key; returns                           # [40, 2, 4, 6]foo.items()                # returns key:value pairs in foo, sorting by key:                           # [('I',40), (1,2), (3,4), (5,6)]foo.pop('I')               # return foo['I'] then remove foo['I']; foo becomes                           # {1:2, 3:4, 5:6}foo.pop('I', 5)            # return 5 because 'I' is not a key of foofoo.pop('I')               # raise KeyError because 'I' is not a key of foo                           # and the optional backup argument (5, above) is                           # unspecified# foo.iteritems(), foo.iterkeys(), foo.itervalues() -- iterator objects# foo.viewitems(), foo.viewkeys(), foo.viewvalues() -- set-like objects#-------------------------------------------------------------------------------# tuple'''tuple() --> empty tuple   tuple(iterable) --> tuple initialized from iterable's items   If the argument is a tuple, the return value is the same object.      Author: Tuples are immutable. Immutability is useful when you don't need to            change the contents of a collection of data. You cannot add or remove            contents from a tuple, and you cannot change elements once assigned.           If you need those capabilities, consider using a list, set or dict.              http://docs.python.org/library/functions.html#tuple   '''tuple()               # returns empty tuple()                    # returns empty tuple(1)                   # returns 1, an integer!(1,)                  # returns (1,) a tuple! the comma is key!(,)                   # in Python 2.7, raises SyntaxErrortuple([1,1])          # returns (1, 1)tuple({1:2, 3:4})     # returns (1, 3) using the dict's keysa, b = (1, 2)         # a becomes 1, b becomes 21, 2, 3               # returns (1, 2, 3)tuple( ((1),(2)) )    # returns (1, 2)tuple( ((1,),(2,)) )  # returns((1,), (2,)) where (1,) and (2,) are tuples                       # inside foo(1, 2) + (3, 4)       # returns (1, 2, 3, 4)(1,) * 5              # returns (1, 1, 1, 1, 1)                      # '+' and '*' are the only valid operands for tuples;                      # this behavior also applies to lists.    # useful methodsfoo = (1, 1, 3, 3)  # foo is (1,2,3,3)foo.count(1)        # returns 2, the number of times 1 is in foofoo.index(3)        # returns 2, the index of the first occurrence of 3 in foo#-------------------------------------------------------------------------------# set'''set() --> new empty set object   set(iterable) --> new set object   Build an unordered collection of unique elements.      http://docs.python.org/library/stdtypes.html#set   '''set()                # returns an empty set, set()set([1,2])           # returns set([1,2])set([1,1,2,2])       # returns set([1,2])set(1)               # returns TypeError: 'int' object is not iterable. The                      # argument to set() must be iterable.set({1:2, 3:4})      # returns set([1,3]) using the dict's keysset([1, '1', 1.0])   # returns set([1, '1'])    # useful methodsfoo = set([1,2,3])foo.add(4)          # adds 4 to foo; foo becomes set([1,2,3,4])foo.add(4)          # does nothing bc 4 is already in foofoo.remove(4)       # removes 4 from foo; foo becomes set([1,2,3])foo.remove(4)       # raise KeyError: 4 because 4 is no longer in foofoo.discard(4)      # attempt to remove 4 from foo; do not raise error if 4 is                    # not a member of foofoo.pop()           # returns an 'arbitrary' element from foo and then removes                    # it from foo. raises KeyError if the set is empty.foo.clear()         # remove all elements from foo; foo becomes set()foo.update([1,2,3]) # make sure we know what foo is; foo becomes set([1,2,3])foo.union([4,5,6])  # returns the union of foo and [4,5,6], which is                    # set([1,2,3,4,5,6]). Does not change foo!foo.difference([1,2,3])                # returns set(), a set containing                                        # elements in foo that                                       # are not in [1,2,3]foo.difference([1])                    # returns set([2, 3])foo.difference([1], [2,3])             # returns set() -- note multiple                                       # argumentsfoo.difference_update([1], [2])        # foo becomes set([3])foo.symmetric_difference([1,2])        # returns set([1,2,3]), the elements                                        # that are                                       # in exactly ONE setfoo.symmetric_difference_update([1,2]) # foo becomes set([1,2,3])foo.issubset([1,2,3,4])      # returns True bc foo is a subset of [1,2,3,4]foo.issuperset([1,2])        # returns True bc foo contains [1,2]foo.isdisjoint([5,6,7])      # returns True bc foo and [5,6,7] do not intersectfoo.isdisjoint([1,2])        # returns False bc foo and [1,2] intersectfoo.intersection([1], [1,2]) # returns set([1]), a set with the elements that                             # are members of foo, [1] and [1,2]foo.intersection([1], [2,3]) # returns set() bc no elements are in all 3 setsfoo.intersection([1])        # returns set([1])foo.intersection_update([1]) # foo becomes its intersection with [1], which is                             # set([1])#-------------------------------------------------------------------------------# frozenset'''frozenset() --> empty frozenset object   frozenset(iterable) --> frozenset object   Build an immutable unordered collection of unique elements.      Author: A frozenset is immutable, meaning that -- just as with tuples -- you           cannot add, remove or change the set's elements. This means that many           of the methods available for normal sets do not apply to frozensets.              http://docs.python.org/library/stdtypes.html#frozenset      AUTHOR: See the 'set' section for fronzenset's methods:           difference, intersection, isdisjoint, issubset, issuperset,           symmetric_difference, union   '''frozenset()         # returns an empty frozenset, frozenset()frozenset([1,2,3])  # returns frozenset([1,2,3])frozenset([1,1,1])  # returns frozenset([1])#===============================================================================#   FUNCTIONS#===============================================================================# abs'''Return the absolute value of the argument.   The argument may be a plain or long integer or a floating point number.    If the argument is a complex number, its magnitude is returned.   abs(number) --> number   AUTHOR: The magnitude of a complex number is the absolute value of that            complex number's vector representation, which connects the origin to            the point (R,i) where R is the value of the real component and i is            the value of the imaginary component. E.g., the complex number (1+3j)            can be represented as the vector connecting points (0,0) and (1,3).            The magnitude of this vector is (1^2 + 3^2)^(1/2) through the            Pythagorean Theorem, sqrt(10), about 3.162.      http://docs.python.org/library/functions.html#abs   '''abs(5)       # returns 5abs(5.0)     # returns 5.0abs(-5)      # returns 5abs('5')     # returns TypeError: bad operand type for abs(): 'str'   #-------------------------------------------------------------------------------# all '''Return True if bool(x) is True for all values x in the iterable.   all(iterable) --> bool      http://docs.python.org/library/functions.html#all   '''all([5<6 ,  6>5, 1 in (1,2)])     # returns True bc all conditions are Trueall([True, True, True      ])     # returns Trueall([True, True, False     ])     # returns False bc not all values are True    # semi-important examplesall(['k', 6, [1], (9,), {5:6}])   # returns True b/c all values are not                                  # empty or Noneall([''])                         # returns False, empty stringall([{}])                         # returns False, empty dictall([])                           # returns True -- odd caseall([[]])                         # returns False, empty listall([None])                       # returns False, null value#-------------------------------------------------------------------------------# any'''Return True if bool(x) is True for any x in the iterable.   any(iterable) --> bool      http://docs.python.org/library/functions.html#any   '''any([True, False, False])       # returns True bc at least one element in the                                # iterable is Trueany([False, False, False])      # returns False bc no elements are True#-------------------------------------------------------------------------------# bin'''Return the binary representation of an integer or long integer.   bin(number) --> string      http://docs.python.org/library/functions.html#bin   '''bin(0)          # returns '0b0'bin(1)          # returns '0b1'bin(2)          # returns '0b10'bin(3)          # returns '0b11'bin(-1)         # returns '-0b1'#-------------------------------------------------------------------------------# callable'''Return whether the object is callable (i.e., some kind of function).   Note that classes are callable, as are instances with a __call__() method.      callable(object) --> bool      http://docs.python.org/library/functions.html#callable   '''callable(max)       # returns True bc 'max' is a callable functionk = 5callable(k)         # returns False bc 'k' is not callableclass MyClass():    passcallable(MyClass)   # returns True bc 'MyClass' can be called to create                    # an instance of itself#-------------------------------------------------------------------------------# chr'''Return a string of one character with ordinal i; 0 <= i < 256.   chr(i) --> character      AUTHOR: Useful for scanning ASCII text. Not a universal solution for           handling decoded Unicode strings, but can work fine in most           situations. Note that your shell/interpreter may display differently           from other shells/interpreters depending on how it handles the           character buffer.      http://docs.python.org/library/functions.html#chr   '''for i in range(256):    print chr(i)        # prints all ASCII characters.chr(55)                 # returns '7'#-------------------------------------------------------------------------------# classmethod'''Convert a function to be a class method.      A class method receives the class as implicit first argument,   just like an instance method receives the instance.   To declare a class method, use this idiom:        class C:         def f(cls, arg1, arg2, ...): ...         f = classmethod(f)      It can be called either on the class (e.g. C.f()) or on an instance   (e.g. C().f()).  The instance is ignored except for its class.   If a class method is called for a derived class, the derived class   object is passed as the implied first argument.      Class methods are different than C++ or Java static methods.   If you want those, see the staticmethod builtin.      classmethod(function) --> method      Author: See 'http://stackoverflow.com/questions/38238/                       what-are-class-methods-in-python-for'           See 'http://stackoverflow.com/questions/136097/                       what-is-the-difference-between-staticmethod-and-                       classmethod-in-python'                          http://docs.python.org/library/functions.html#classmethod   '''class MyClass():        def f(cls, x):  # notice implicit first argument with special syntax, 'cls'        return x * x            f = classmethod(f)    MyClass.f(5)            # returns 25instance = MyClass()    # save an instance of the classinstance.f(5)           # returns 25, same as MyClass().f(5)#-------------------------------------------------------------------------------# cmp'''Return negative if x<y, zero if x==y, positive if x>y.   cmp(x, y) --> integer   http://docs.python.org/library/functions.html#cmp   '''cmp(1, 100)         # returns -1 bc 1 < 100cmp(1, 1)           # returns 0 bc 1 == 1cmp(100, 1)         # returns  1 bc 100 > 1cmp([1], [1])       # returns 0cmp([1], [9])       # returns -1cmp([9], [1])       # returns  1#-------------------------------------------------------------------------------# compile'''Compile the source string (a Python module, statement or expression)   into a code object that can be executed by the exec statement or eval().   The filename will be used for run-time error messages.   The mode must be 'exec' to compile a module, 'single' to compile a   single (interactive) statement, or 'eval' to compile an expression.   The flags argument, if present, controls which future statements influence   the compilation of the code.   The dont_inherit argument, if non-zero, stops the compilation inheriting   the effects of any future statements in effect in the code calling   compile; if absent or zero these statements do influence the compilation,   in addition to any features explicitly specified.      compile(source, filename, mode[, flags[, dont_inherit]]) --> code object      AUTHOR: Although I haven't used this function, it could be useful for           improving performance in loops when calling non-built-in code           inside nested loops. My initial tests show that there would            have to be a significant advantage, however, because calling           the eval function on the compiled code involves a lot of           overhead (as all Python function calls do).      http://docs.python.org/library/functions.html#compile   '''foo = compile('1+1', 'test.txt', 'single')eval(foo)   # returns 2foo = compile('newVar=5', 'test.txt', 'eval') # returns SyntaxErrorfoo = compile('newVar=5', 'test.txt', 'single')eval(foo)print newVar    # prints 5foo = compile('n % 2 == 1', 'test.txt', 'eval')for n in range(100):    true_or_false = eval(foo) # evaluates 'n % 2 == 1' for each n    if true_or_false is True:        print n#-------------------------------------------------------------------------------# delattr'''Delete a named attribute on an object; delattr(x, 'y') is equivalent to   ``del x.y''.      delattr(object, name)      http://docs.python.org/library/functions.html#delattr   '''class MyClass():    def __init__(self):        self.prop = 'this property is called prop'        obj = MyClass()print obj.prop        # prints 'this property is called prop'delattr(obj, 'prop')  # removes 'prop' attribute from objprint obj.prop        # raises AttributeError: MyClass instance has no                          # attribute 'prop'#-------------------------------------------------------------------------------# divmod'''Take two (non-complex) numbers as arguments and return a pair of numbers    consisting of their quotient and remainder when using long division. With    mixed operand types, the rules for binary arithmetic operators apply.    For plain and long integers, the result is the same as (a // b, a % b).    For floating point numbers the result is (q, a % b), where q is usually    math.floor(a / b) but may be 1 less than that. In any case q * b + a % b is    very close to a, if a % b is non-zero it has the same sign as b, and    0 <= abs(a % b) < abs(b).   divmod(x, y) --> (div, mod)   '''divmod(5, 5)        # returns (1, 0)divmod(19, 6)       # returns (3, 1) ... notice 3*6=18; 18+1=19#-------------------------------------------------------------------------------# enumerate'''Return an enumerate object.  iterable must be another object that supports   iteration.  The enumerate object yields pairs containing a count (from   start, which defaults to zero) and a value yielded by the iterable argument.   enumerate is useful for obtaining an indexed list:       (0, seq[0]), (1, seq[1]), (2, seq[2]), ...      enumerate(iterable[, start]) -> iterator for index, value of iterable      http://docs.python.org/library/functions.html#enumerate   '''enumerate([1,2])            # returns <enumerate object at ___>, a generator- or                            # iterator-like objectfoo = enumerate(['1','2'])  # foo becomes <enumerate object at ___>foo.next()                  # returns (0, '1'), which represents (index, value)foo.next()                  # returns (1, '2')foo = enumerate(['1','2'])for x in foo:               # prints (0, '1'), (1, '2')    print xfor x in foo:               # prints nothing bc the enumerate object foo is     print x                 # exhausted    foo = enumerate(['1','2'])for enum,val in x:          # only prints indexes -- prints 0, 1    print enum#-------------------------------------------------------------------------------# execfile'''Read and execute a Python script from a file.   The globals and locals are dictionaries, defaulting to the current   globals and locals.  If only globals is given, locals defaults to it.      http://docs.python.org/library/functions.html#execfile   '''execfile('Somefile.py')#-------------------------------------------------------------------------------# file'''Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),   writing or appending.  The file will be created if it doesn't exist   when opened for writing or appending; it will be truncated when   opened for writing.  Add a 'b' to the mode for binary files.   Add a '+' to the mode to allow simultaneous reading and writing.   If the buffering argument is given, 0 means unbuffered, 1 means line   buffered, and larger numbers specify the buffer size.        NB:   The preferred way to open a file is with the builtin open() function!      Add a 'U' to mode to open the file for input with universal newline   support.  Any line ending in the input file will be seen as a '\n'   in Python.  Also, a file so opened gains the attribute 'newlines';   the value for this attribute is one of None (no newline read yet),   '\r', '\n', '\r\n' or a tuple containing all the newline types seen.      'U' cannot be combined with 'w' or '+' mode.      file(name[, mode[, buffering]]) --> file object      http://docs.python.org/library/functions.html#file   '''#-------------------------------------------------------------------------------# filter'''Return those items of sequence for which function(item) is true.  If   function is None, return the items that are true.  If sequence is a tuple   or string, return the same type, else return a list.      filter(function or None, sequence) --> list, tuple or string      http://docs.python.org/library/functions.html#filter   '''filter(lambda x: x > 5, (4,5,6))    # returns (6,)filter(str.isupper, 'AbcdE')        # returns 'AE'filter(None, [1, 0, None, '', {}])  # returns [1]#-------------------------------------------------------------------------------# format'''Convert a value to a “formatted” representation, as controlled by    format_spec. The interpretation of format_spec will depend on the type of    the value argument, however there is a standard formatting syntax that is    used by most built-in types:   http://docs.python.org/library/string.html#formatspec      Returns value.__format__(format_spec)   format_spec defaults to ""      format(value[, format_spec]) --> string      http://docs.python.org/library/functions.html#format   '''#-------------------------------------------------------------------------------# getattr'''   Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.   When a default argument is given, it is returned when the attribute doesn't   exist; without it, an exception is raised in that case.      getattr(object, name[, default]) --> value      http://docs.python.org/library/functions.html#getattr   '''class MyClass():        def __init__(self):        self.attrib = 'value'        obj = MyClass()         # save an instance of the classgetattr(obj, 'attrib')  # returns 'value'getattr(obj, 'attrib2') # returns AttributeError: MyClass instance has no                        # attribute 'attrib2'getattr(obj, 'attrib2', 'default')  # returns 'default' bc 'attrib2' is not a                                    # property of obj#-------------------------------------------------------------------------------# globals'''Return the dictionary containing the current scope's global variables.   Return a dictionary representing the current global symbol table. This is    always the dictionary of the current module (inside a function or method,    this is the module where it is defined, not the module from which it is    called).      globals() --> dictionary      http://docs.python.org/library/functions.html#globals   '''c = 5globals()['c']      # returns 5#-------------------------------------------------------------------------------# hasattr'''Return whether the object has an attribute with the given name.   (This is done by calling getattr(object, name) and catching exceptions.)      hasattr(object, name) --> bool      http://docs.python.org/library/functions.html#hasattr   '''class MyClass():        def __init__(self):        self.attrib = 'value'        obj = MyClass()                 # save an instance of the classhasattr(obj, 'attrib')          # returns Truehasattr(str, 'upper')           # returns Truehasattr(frozenset, 'update')    # returns False#-------------------------------------------------------------------------------# hash'''Return a hash value for the object.  Two objects with the same value have   the same hash value.  The reverse is not necessarily true, but likely.      hash(object) --> integer      http://docs.python.org/library/functions.html#hash   '''hash(10)    # returns 10hash(9000)  # returns 9000hash(max)   # returns -1042237177 on my machinehash([1,2]) # returns TypeError: unhashable type: list. Hashable objects are            # immutable, so mutable objects (like lists and dicts) are not            # hashable types.a = 5b = 5hash(a)     # returns 5hash(b)     # returns 5#-------------------------------------------------------------------------------# hex'''Return the hexadecimal representation of an integer or long integer.   hex(number) --> string      http://docs.python.org/library/functions.html#hex   '''hex(1)      # returns '0x1'hex(100)    # returns '0x64'hex(1000)   # returns '0x3e8'#-------------------------------------------------------------------------------# id'''Return the identity of an object.  This is guaranteed to be unique among   simultaneously existing objects.  (It's the object's memory address.)      id(object) --> integer      http://docs.python.org/library/functions.html#id   '''id(max)     # returns 19275904 on my machineid(5)       # returns 19572416 on my machine#-------------------------------------------------------------------------------# isinstance '''Return whether an object is an instance of a class or of a subclass thereof.   With a type as second argument, return whether that is the object's type.   The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for   isinstance(x, A) or isinstance(x, B) or ... (etc.).      isinstance(object, class-or-type-or-tuple) --> bool      http://docs.python.org/library/functions.html#isinstance   '''isinstance(5, int)      # returns Trueisinstance(5, float)    # returns Falseclass MyClass():    passobj = MyClass()isinstance(obj, MyClass) # returns True#-------------------------------------------------------------------------------# iter'''Return an iterator object. The first argument is interpreted very differently    depending on the presence of the second argument. Without a second argument,    o must be a collection object which supports the iteration protocol    (the __iter__() method), or it must support the sequence protocol    (the __getitem__() method with integer arguments starting at 0). If it does    not support either of those protocols, TypeError is raised. If the second    argument, sentinel, is given, then o must be a callable object. The iterator    created in this case will call o with no arguments for each call to its    next() method; if the value returned is equal to sentinel, StopIteration will    be raised, otherwise the value will be returned.   One useful application of the second form of iter() is to read lines of a    file until a certain line is reached. The following example reads a file    until the readline() method returns an empty string:   with open('mydata.txt') as fp:       for line in iter(fp.readline, ''):           process_line(line)              iter(collection) --> iterator   iter(callable, sentinel) --> iterator              http://docs.python.org/library/functions.html#iter   '''iter([1,2,3])           # returns iterator object for this listfor x in iter([1,2,3]): # prints each element on a new line    print x     #-------------------------------------------------------------------------------# len'''Return the number of items of a sequence or mapping.   len(object) --> integer   http://docs.python.org/library/functions.html#len   '''len([1,2,3])        # returns 3len({1:[1.0,1.1]})  # returns 1#-------------------------------------------------------------------------------# locals'''Update and return a dictionary containing the current scope's local    variables.      locals() --> dictionary      AUTHOR: At the global scope, locals() == globals() (as far as I know).      http://docs.python.org/library/functions.html#locals   '''#-------------------------------------------------------------------------------# map'''Return a list of the results of applying the function to the items of   the argument sequence(s).  If more than one sequence is given, the   function is called with an argument list consisting of the corresponding   item of each sequence, substituting None for missing values when not all   sequences have the same length.  If the function is None, return a list of   the items of the sequence (or a list of tuples if more than one sequence).      map(function, sequence[, sequence, ...]) --> list      http://docs.python.org/library/functions.html#map   '''from math import sqrtmap(sqrt, [0, 1, 4, 9])         # returns [0.0, 1.0, 2.0, 3.0]map(str, [0, 1, 2, 3])          # returns ['0', '1', '2', '3']map(lambda x: x/5, [0,5,10,15]) # returns [0.0, 1.0, 2.0, 3.0]map(max, (9,2,3), (4,5,6))      # returns (9, 5, 6) by returning the max value                                # at each index for each sequencemap(min, (1,1,1,1), (1,))       # returns (1, None, None, None)#-------------------------------------------------------------------------------# max'''With a single iterable argument, return its largest item.   With two or more arguments, return the largest argument.   With a single argument iterable, return the largest item of a non-empty    iterable (such as a string, tuple or list). With more than one argument,    return the largest of the arguments.   The optional key argument specifies a one-argument ordering function like    that used for list.sort(). The key argument, if supplied, must be in keyword    form (for example, max(a,b,c,key=func)). See this site for help sorting:   http://wiki.python.org/moin/HowTo/Sorting   max(iterable[, key=func]) --> value   max(a, b, c, ...[, key=func]) --> value   http://docs.python.org/library/functions.html#max   '''max([999, 0, 3])        # returns 999max([1,999], [2,0])     # returns [2,0] bc its first element is the largest 1st                        # element of all argument sequences#-------------------------------------------------------------------------------# min'''With a single iterable argument, return its smallest item.   With two or more arguments, return the smallest argument.   min(iterable[, key=func]) -> value   min(a, b, c, ...[, key=func]) -> value   http://docs.python.org/library/functions.html#min   '''min([1,2,3])                # returns 1min([0,-9000], [-1, 9000])  # returns [-1, 9000] bc its first element is the                            # smallest 1st element of all argument sequences#-------------------------------------------------------------------------------# next'''Return the next item from the iterator. If default is given and the iterator   is exhausted, it is returned instead of raising StopIteration.   next(iterator[, default])   http://docs.python.org/library/functions.html#next   '''foo = iter([1,2,3])next(foo)      # returns 1, foo becomes iter([2,3])next(foo)      # returns 2, foo becomes iter([3])next(foo)      # returns 3, foo becomes iter([]), StopIteration is reached, the               # iterator is exhaustednext(foo)      # returns StopIteration exceptionfoo = iter([1])next(foo, -999) # returns 1, iterator is exhaustednext(foo, -999) # returns -999 because the optional 'default' argument was givennext(foo, -999) # returns -999 because the optional 'default' argument was given#-------------------------------------------------------------------------------# oct'''Return the octal representation of an integer or long integer.   oct(number) --> string   http://docs.python.org/library/functions.html#oct   '''oct(1)      # returns '01'oct(10)     # returns '012'oct(100)    # returns '0144'#-------------------------------------------------------------------------------# open '''Open a file using the file() type, returns a file object.  This is the   preferred way to open a file.  See file.__doc__ for further information.   open(name[, mode[, buffering]]) --> file object   AUTHOR: See documentation at link below for important details!   http://docs.python.org/library/functions.html#open   '''    # use with statement to open a file -- best waywith open('somefile.txt', 'r') as open_file:    # 'r' is read-only    print 'do something'    pass    # file is automatically closed upon restoring indentationfoo = open('newFile.txt', 'w')  # 'w' is write mode-creates file if doesnt existfoo.close() # must manually close file!foo = open('pickle.pkl', 'rb') # open a binary file in read-only modefoo.close()#-------------------------------------------------------------------------------# ord'''Return the integer ordinal of a one-character string.   ord(c) --> integer   AUTHOR: Be very careful when using ord() on characters converted to a str           froma Unicode object! Use a try-except block.   http://docs.python.org/library/functions.html#ord   '''ord('123')      # returns TypeError: ord() expected a character, but a string of                # length 3 foundord('1')        # returns 49ord('\n')       # returns 10ord('\t')       # returns  9ord('§')        # returns 167ord('¶')        # returns 182#-------------------------------------------------------------------------------# pow'''With two arguments, equivalent to x**y.  With three arguments,   equivalent to (x**y) % z, but may be more efficient (e.g. for longs).   pow(x, y[, z]) --> number   http://docs.python.org/library/functions.html#pow   '''pow(2, 2)       # returns 4pow(2, 5)       # returns 32pow(2, 5, 3)    # returns 2, the whole-number remainder of 32/3, or 32 % 3#-------------------------------------------------------------------------------# range'''Return a list containing an arithmetic progression of integers.   range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.   When step is given, it specifies the increment (or decrement).   For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!   These are exactly the valid indices for a list of 4 elements.   range([start,] stop[, step]) --> list of integers   http://docs.python.org/library/functions.html#range   '''range(4)            # returns [0, 1, 2, 3]range(2, 4)         # returns [2, 3]range(0, 25, 5)     # returns [0, 5, 10, 15, 20]range(25, 0, -5)    # returns [25, 20, 15, 10, 5]range(0, 25, -5)    # returns []#-------------------------------------------------------------------------------# raw_input'''Read a string from standard input.  The trailing newline is stripped.   If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.   On Unix, GNU readline is used if enabled.  The prompt string, if given,   is printed without a trailing newline before reading.   raw_input([prompt]) --> string   http://docs.python.org/library/functions.html#raw_input   '''raw_input()         # waits for user to type in standard input (cmd prompt/shell)                    # and hit enterfoo = raw_input()   # foo takes the user's input string as its valuefoo = raw_input(r)  # prompt prepends the 'r' char to the beginning of the input                    # string. This is the same as r'SomeString', making foo a                    # raw string. Any `prompt` given to raw_input as an argument                    # is prepended to the input string.#-------------------------------------------------------------------------------# reduce'''   Apply a function of two arguments cumulatively to the items of a sequence,   from left to right, so as to reduce the sequence to a single value.   For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates   ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items   of the sequence in the calculation, and serves as a default when the   sequence is empty.   reduce(function, sequence[, initial]) --> value   http://docs.python.org/library/functions.html#reduce   '''reduce(lambda x,y: x*y, [5,4,3,2,1])        # returns 120, aka 5! (factorial)reduce(lambda x,y: x*y, [1,2,3,4,5], 10)    # returns 1200, aka 10 * (5!)reduce(lambda x,y: x*y, [0])                # returns 0reduce(lambda x,y: x*y, [0], 1)             # returns 0reduce(lambda x,y: x*y, [])                 # returns TypeError: reduce() of                                            # empty sequence with no initial                                            # valuereduce(lambda x,y: x*y, [], 1)              # returns 1 by using 1 as the first                                            # value of x.#-------------------------------------------------------------------------------# reload'''Reload the module.  The module must have been successfully imported before.   reload(module) --> module   reload http://docs.python.org/library/functions.html#reload   '''foo = 'foo'reload(foo)         # return TypeError: reload() argument must be modulereload(numpy)       # return NameError: name 'numpy' is not definedimport numpyreload(numpy)       # reloads numpy if numpy imports correctly#-------------------------------------------------------------------------------# repr'''Return the canonical string representation of the object.   For most object types, eval(repr(object)) == object.   repr(object) --> string   http://docs.python.org/library/functions.html#repr   '''repr(1)             # returns '1'repr([1,2,3])       # returns '[1,2,3]'eval(repr([1,2])    # returns [1,2]#-------------------------------------------------------------------------------# reversed'''Return a reverse iterator   reversed(sequence) -> reverse iterator over values of the sequence   http://docs.python.org/library/functions.html#reversed   '''foo = reversed([1,2,3])     # returns iterator object over [3,2,1]foo[1]                      # returns TypeError: 'listreverseiterator' object is                            # not subscriptablefoo.next()                  # returns 3, foo becomes iterator over [2,1]foo.next()                  # returns 2, foo becomes iterator over [1]foo.next()                  # returns 1, iterator foo is exhaustedfoo.next()                  # returns StopIteration exception#-------------------------------------------------------------------------------# round'''Round a number to a given precision in decimal digits (default 0 digits).   This always returns a floating point number.  Precision may be negative.      round(number[, ndigits]) --> floating point number      http://docs.python.org/library/functions.html#round   '''round(5.9)      # returns 6.0round(5.9, 1)   # returns 5.9round(5.9, 900) # returns 5.9round(5.9, -1)  # returns 10.0 -- rounds to nearest multiple of 10^1round(1.1, -1)  # returns 0.0round(5.9, -2)  # returns 0.0 -- rounds to nearest multiple of 10^2round(80.0, -2) # returns 100.0round(5.9, -3)  # returns 0.0 -- rounds to nearest multiple of 10^3round(499, -3)  # returns 0.0round(500, -3)  # returns 1000.0round(2.675, 2)     # returns 2.67 -- lack of precision in binary numbersimport numpy as npnp.round(2.675, 2)  # returns 2.6800000000000002 -- simulated precision#-------------------------------------------------------------------------------# setattr'''Set a named attribute on an object; setattr(x, 'y', v) is equivalent to   ``x.y = v''.   setattr(object, name, value)   http://docs.python.org/library/functions.html#setattr   '''foo = 5foo.__str__()       # returns '5'setattr(k, '__str__', 'foobar') # returns AttributeError: 'int' object attribute                                # '__str__' is read-onlysetattr(k, 'newAttr', 'foobar') # returns AttributeError: 'int' object has no                                # attribute 'newAttr'class MyClass():    def __init__(self):        self.attr = 'Go Heels'        obj = MyClass()     # create an instance of the classprint obj.attr      # prints 'Go Heels'setattr(obj, 'attr', 'Roy Williams rocks')print obj.attr      # prints 'Roy Williams rocks'obj.attr = 'NCAA 2012?!'print obj.attr      # prints 'NCAA 2012?!'#-------------------------------------------------------------------------------# sorted'''sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list   AUTHOR: I highly recommend reading http://wiki.python.org/moin/HowTo/Sorting/   http://docs.python.org/library/functions.html#sorted   '''foo = [5, 2, 3, 1, 4]sorted(foo)                         # returns [1, 2, 3, 4, 5]sorted(foo, reverse=True)           # returns [5, 4, 3, 2, 1]sorted({1:2, 3:4})                  # returns [1, 3]sorted((3,1,2))                     # returns [1, 2, 3]sorted(iter([3, 1, 2]))             # returns [1, 2, 3]sorted(['b', 'B', 'z', 'a', 'Z'])   # returns ['B', 'Z', 'a', 'b', 'z']#-------------------------------------------------------------------------------# sum'''Returns the sum of a sequence of numbers (NOT strings) plus the value   of parameter 'start' (which defaults to 0).  When the sequence is   empty, returns start.      sum(sequence[, start]) --> value      http://docs.python.org/library/functions.html#sum   '''sum([1,2,3])     # returns 6sum({1:2, 3:4})  # returns 4, the sum of the keyssum([1,2,3], 6]) # returns 12; same as sum(1,2,3) + 6#-------------------------------------------------------------------------------# staticmethod'''Convert a function to be a static method.   A static method does not receive an implicit first argument.   To declare a static method, use this idiom:           class C:        def f(arg1, arg2, ...): ...        f = staticmethod(f)      It can be called either on the class (e.g. C.f()) or on an instance   (e.g. C().f()).  The instance is ignored except for its class.      Static methods in Python are similar to those found in Java or C++.   For a more advanced concept, see the classmethod builtin.      staticmethod(function) --> method      AUTHOR: See 'http://stackoverflow.com/questions/136097/                       what-is-the-difference-between-staticmethod-and-                       classmethod-in-python'   '''class MyClass():    def f(x):           # notice no implicit first argument        return x * x            f = staticmethod(f)    MyClass.f(5)         # returns 25instance = MyClass() # save an instance of the classinstance.f(5)        # returns 25#-------------------------------------------------------------------------------# super'''super(type) -> unbound super object   super(type, obj) -> bound super object; requires isinstance(obj, type)   super(type, type2) -> bound super object; requires issubclass(type2, type)      Typical use to call a cooperative superclass method:   class C(B):       def meth(self, arg):           super(C, self).meth(arg)   super(type) -> unbound super object      AUTHOR: See 'http://stackoverflow.com/questions/222877/                       how-to-use-super-in-python'      http://docs.python.org/library/functions.html#super   '''#-------------------------------------------------------------------------------# unichr'''Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.      unichr(i) --> Unicode character      http://docs.python.org/library/functions.html#unichr   '''unichr(100)     # returns u'd'#-------------------------------------------------------------------------------# vars'''Without arguments, equivalent to locals().   With an argument, equivalent to object.__dict__.   vars([object]) --> dictionary   http://docs.python.org/library/functions.html#vars   '''vars() == globals() == locals()     # at the global scope, returns True because                                    # the global namespace's variables are also                                    # its local variables, and vars() returns                                    # all variables in the current namespace#-------------------------------------------------------------------------------# xrange'''Like range(), but instead of returning a list, returns an object that   generates the numbers in the range on demand.  For looping, this is   slightly faster than range() and more memory efficient.      xrange([start,] stop[, step]) -> xrange object      AUTHOR: See 'range' for       http://docs.python.org/library/functions.html#xrange   '''xrange(5)           # returns xrange(5)for x in xrange(5): # prints 0,1,2,3,4    print xfoo = xrange(5)     # sets 'foo' to xrange(5), which is an xrange version of                    # [0, 1, 2, 3, 4]foo[0]              # returns 0foo[-1]             # returns 4foo[:-1]            # returns TypeError: sequence index must be integer, not                    # 'slice'#-------------------------------------------------------------------------------# zip'''Return a list of tuples, where each tuple contains the i-th element   from each of the argument sequences.  The returned list is truncated   in length to the length of the shortest argument sequence.      zip(seq1 [, seq2 [...]]) -> [(seq1[0], seq2[0] ...), (...)]      http://docs.python.org/library/functions.html#zip   '''zip([1,2,3])                # returns [(1,), (2,), (3,)]zip([1.0, 1.1], [2.0, 2.1]) # returns [(1.0, 2.0), (1.1, 2.1)]zip([1], [1,2,3,4,5])       # returns [(1,1)] because [1] is a limiting factor